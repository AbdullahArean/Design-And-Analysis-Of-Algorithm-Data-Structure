# Design-and-Analysis-of-Algorithm
.<br>
├── BS0: Binary Search<br>
│   ├── binarysearch.cpp<br>
│   ├── distancevitto.cpp<br>
│   ├── FindFloorOfAElementInSortedArray.cpp<br>
│   ├── inp.txt<br>
│   ├── kk.cpp<br>
│   ├── LeetCode30.cpp<br>
│   ├── MinimumDifferenceElementInASortedArray.cpp<br>
│   ├── n+nod.cpp<br>
│   ├── Notes.txt<br>
│   ├── peakelement.cpp<br>
│   ├── RotationNumberInSortedRotatedArrayAndIndexOfMinimumElement.cpp<br>
│   ├── SearchAnElementInSortedRotatedArray.cpp<br>
│   ├── SearchingInANearlySortedArray.cpp<br>
│   ├── set_stl_usasge.cpp<br>
│   ├── sqrt.cpp<br>
├── DP0 : Recursion & Backtracking<br>
│   ├── brackets.cpp<br>
│   ├── consecutiveone.cpp<br>
│   ├── friendpairing.cpp<br>
│   ├── hamiltonianpath.cpp<br>
│   ├── input.txt<br>
│   ├── nqueenscount.cpp<br>
│   ├── nqueens.cpp<br>
│   ├── output.txt<br>
│   ├── subsetprint.cpp<br>
│   ├── sudokosolver.cpp<br>
│   ├── tiling_problem.cpp<br>
│   └── towerofhanoi.cpp<br>
├── DP1: Dynamic Programming<br>
│   ├── knapsack_bottomup.cpp<br>
│   ├── knapsack_memo.cpp<br>
│   ├── knapsack_rec.cpp<br>
│   ├── knapsack_testcase.py<br>
│   ├── lcs_bottomup.cpp<br>
│   ├── lcs_memo.cpp<br>
│   ├── lcs_rec.cpp<br>
│   ├── lcs_testcase.py<br>
│   ├── lis_bottomup.cpp<br>
│   ├── lis_memo.cpp<br>
│   ├── lis_rec.cpp<br>
│   ├── lis_testcase.py<br>
│   ├── PrintSetBit.cpp<br>
│   ├── rockclimbing.cpp<br>
│   ├── rockclimbing.py<br>
│   ├── rockclimbing_rec.cpp<br>
│   ├── rodcutting_bottomup.cpp<br>
│   ├── rodcutting_memo.cpp<br>
│   ├── rodcutting_rec.cpp<br>
│   ├── rodcutt_testcase.py<br>
│   ├── test_knapsack.py<br>
│   ├── test_lcs.py<br>
│   ├── test_lis.py<br>
│   └── test_rod.py<br>
├── DP2: Matrix Chain Multiplication<br>
│   ├── MCMBottomUp.cpp<br>
│   ├── MCMmemoization.cpp<br>
│   └── MCMRecursion.cpp<br>
├── DS0: Stack Queue LinkedList<br>
│   ├── allfix_final.cpp<br>
│   ├── circularqueue.cpp<br>
│   ├── infixpostfixprefix.cpp<br>
│   ├── infixtoevaluation.cpp<br>
│   ├── LinkedList.cpp<br>
│   ├── ParanthesesRelated-1.cpp<br>
│   ├── ParanthesesRelated.cpp<br>
│   └── stackqueue.cpp<br>
├── DS1: Tree Binary Tree<br>
│   ├── avltree.cpp<br>
│   ├── BinaryTree.cpp<br>
│   └── BST.cpp<br>
├── DS2: Heap<br>
│   ├── binaryheap.cpp<br>
│   └── BinomialHeap.cpp<br>
├── G1: Basic Graph (BFS, DFS)<br>
│   ├── Bfs.java<br>
│   ├── BfsShortestPath.java<br>
│   ├── Bipartite.java<br>
│   ├── bipartitie.cpp<br>
│   ├── cycle_detection_directed.cpp<br>
│   ├── CycleDetectionDirected.java<br>
│   ├── cycle_detection_undirected.cpp<br>
│   ├── CycleDetectionUndirected.java<br>
│   ├── dfs.java<br>
│   ├── Graph.cpp<br>
│   ├── graphwithedges.cpp<br>
│   ├── topological_sort.cpp<br>
│   └── topologicalSort.java<br>
├── G2: Grid Recursion<br>
│   ├── floodfillalgo.cpp<br>
│   ├── labshortestpathgrid.cpp<br>
│   ├── minimumstepknightneedtoreachtarget.cpp<br>
│   └── ratinamze.cpp<br>
├── G4: Disjoint Set Union<br>
│   ├── dsu1.cpp<br>
│   ├── dsu2.cpp<br>
│   ├── DSUrankPathCompression.java<br>
│   └── inp.txt<br>
├── G5: Bridge Articulation Point<br>
│   ├── articulation point and bridges.cpp<br>
│   ├── ArticulationPointAndBridges.java<br>
│   ├── bestEulerTour.java<br>
│   ├── bridge_articulation.cpp<br>
│   ├── bridge.cpp<br>
│   ├── EulerTour.java<br>
│   ├── inp.txt<br>
│   ├── input1.txt<br>
│   ├── output1.txt<br>
│   └── output.txt<br>
├── G6: Euler Circuit<br>
│   ├── best euler tour.cpp<br>
│   ├── euler tours.cpp<br>
│   └── inp.txt<br>
├── G7: Strongly Connected Compound<br>
│   ├── inp.txt<br>
│   ├── kosaraju algorithm for SCC.cpp<br>
│   ├── KosarajuAlgorithm.java<br>
│   ├── scc.cpp<br>
│   ├── topological Order.cpp<br>
│   └── TopologicalOrder.java<br>
├── G8: Minimum Spanning Tree<br>
│   ├── input1.txt<br>
│   ├── input2.txt<br>
│   ├── input3.txt<br>
│   ├── input4.txt<br>
│   ├── Kruskal Algo Test Driver Code.py<br>
│   ├── Kruskal.java<br>
│   ├── Kruskal_MST.cpp<br>
│   ├── Prim Algo Test Driver Code.py<br>
│   ├── Prim_MST.cpp<br>
│   ├── Prim’s and Kruskal’s Algorithm for Minimum Spanning Tree Analysis.pdf<br>
│   ├── Prims.java<br>
│   ├── Random_Graph_Generation.py<br>
│   └── README.md<br>
├── G9: Shortest Path Algorithm<br>
│   ├── G9.1: Single Source Shortest Path<br>
│   │   ├── 743.network-delay-time.cpp<br>
│   │   ├── bellmanford.cpp<br>
│   │   ├── dijkastra.cpp<br>
│   │   ├── inputdj.txt<br>
│   │   └── Readme.md<br>
│   └── G9.2: All Pair Shortest Path<br>
│       ├── floydwarshallworking.cpp<br>
│       ├── inputdj.txt<br>
│       ├── jhonsonfinal.cpp<br>
│       ├── jhonsons2working.cpp<br>
│       ├── jhonsonsalgorithm.cpp<br>
│       ├── jhonsonscoded.cpp<br>
│       └── output.txt<br>
├── Greedy: Huffman Coding<br>
│   ├── hf1.cpp<br>
│   ├── hf2.cpp<br>
│   └── hftemplate.cpp<br>
├── NF0: Network Flow Basic<br>
│   ├── dinicsAlgo.java<br>
│   ├── dinic's algprithm.cpp<br>
│   ├── driver2.cpp<br>
│   ├── driver.cpp<br>
│   ├── edmond-karp-coded.cpp<br>
│   ├── edmond-karp.cpp<br>
│   ├── edmondkarp_fordfulkerson.cpp<br>
│   ├── inp.txt<br>
│   ├── mbm_maxflow.cpp<br>
│   ├── showsir2.sh<br>
│   ├── showsir.sh<br>
│   └── sirinput.txt<br>
├── NT1: Eucleadian Algorithm GCD<br>
│   ├── gcd_extended.cpp<br>
│   ├── Linear_diaphantine_eqn.png<br>
│   ├── Linear_Diophantine_Equations.cpp<br>
│   ├── multiplicative_modulo_inverse.cpp<br>
│   └── Multiplicative_Modulo_Inverse_using_extended_Eucledian.png<br>
├── Sort1: Sorting Algo<br>
│   ├── CountingInversionUsingMergeSort.cpp<br>
│   └── sorting.cpp<br>
└── T1: Segment Tree<br>
    ├── FLIPCOIN-codechef.cpp<br>
    ├── Readme.md<br>
    ├── segmenttree.cpp<br>
    └── segment+tree+with+lazy+propagation.cpp<br>
