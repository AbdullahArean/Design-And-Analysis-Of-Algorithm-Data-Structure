# Design-and-Analysis-of-Algorithm
.
├── BS0: Binary Search
│   ├── binarysearch.cpp
│   ├── binarysearchtemp.cpp
│   ├── distancevitto.cpp
│   ├── FindFloorOfAElementInSortedArray.cpp
│   ├── inp.txt
│   ├── kk
│   ├── kk.cpp
│   ├── LeetCode30.cpp
│   ├── MinimumDifferenceElementInASortedArray.cpp
│   ├── n+nod.cpp
│   ├── Notes.txt
│   ├── output.txt
│   ├── peakelement.cpp
│   ├── RotationNumberInSortedRotatedArrayAndIndexOfMinimumElement.cpp
│   ├── SearchAnElementInSortedRotatedArray.cpp
│   ├── SearchingInANearlySortedArray.cpp
│   ├── set_stl_usasge.cpp
│   ├── sqrt.cpp
│   └── tempCodeRunnerFile
├── DP0 : Recursion & Backtracking
│   ├── brackets.cpp
│   ├── consecutiveone.cpp
│   ├── friendpairing.cpp
│   ├── hamiltonianpath.cpp
│   ├── input.txt
│   ├── nqueenscount.cpp
│   ├── nqueens.cpp
│   ├── output.txt
│   ├── subsetprint.cpp
│   ├── sudokosolver.cpp
│   ├── tiling_problem.cpp
│   └── towerofhanoi.cpp
├── DP1: Dynamic Programming
│   ├── knapsack_bottomup.cpp
│   ├── knapsack_memo.cpp
│   ├── knapsack_rec.cpp
│   ├── knapsack_testcase.py
│   ├── lcs_bottomup.cpp
│   ├── lcs_memo.cpp
│   ├── lcs_rec.cpp
│   ├── lcs_testcase.py
│   ├── lis_bottomup.cpp
│   ├── lis_memo.cpp
│   ├── lis_rec.cpp
│   ├── lis_testcase.py
│   ├── PrintSetBit.cpp
│   ├── rockclimbing.cpp
│   ├── rockclimbing.py
│   ├── rockclimbing_rec.cpp
│   ├── rodcutting_bottomup.cpp
│   ├── rodcutting_memo.cpp
│   ├── rodcutting_rec.cpp
│   ├── rodcutt_testcase.py
│   ├── test_knapsack.py
│   ├── test_lcs.py
│   ├── test_lis.py
│   └── test_rod.py
├── DP2: Matrix Chain Multiplication
│   ├── MCMBottomUp.cpp
│   ├── MCMmemoization.cpp
│   └── MCMRecursion.cpp
├── DS0: Stack Queue LinkedList
│   ├── allfix_final.cpp
│   ├── circularqueue.cpp
│   ├── infixpostfixprefix.cpp
│   ├── infixtoevaluation.cpp
│   ├── LinkedList.cpp
│   ├── ParanthesesRelated-1.cpp
│   ├── ParanthesesRelated.cpp
│   └── stackqueue.cpp
├── DS1: Tree Binary Tree
│   ├── avltree.cpp
│   ├── BinaryTree.cpp
│   └── BST.cpp
├── DS2: Heap
│   ├── binaryheap.cpp
│   └── BinomialHeap.cpp
├── G1: Basic Graph (BFS, DFS)
│   ├── Bfs.java
│   ├── BfsShortestPath.java
│   ├── Bipartite.java
│   ├── bipartitie.cpp
│   ├── cycle_detection_directed.cpp
│   ├── CycleDetectionDirected.java
│   ├── cycle_detection_undirected.cpp
│   ├── CycleDetectionUndirected.java
│   ├── dfs.java
│   ├── Graph.cpp
│   ├── graphwithedges.cpp
│   ├── topological_sort.cpp
│   └── topologicalSort.java
├── G2: Grid Recursion
│   ├── floodfillalgo.cpp
│   ├── labshortestpathgrid.cpp
│   ├── minimumstepknightneedtoreachtarget.cpp
│   └── ratinamze.cpp
├── G4: Disjoint Set Union
│   ├── dsu1.cpp
│   ├── dsu2.cpp
│   ├── DSUrankPathCompression.java
│   └── inp.txt
├── G5: Bridge Articulation Point
│   ├── articulation point and bridges.cpp
│   ├── ArticulationPointAndBridges.java
│   ├── bestEulerTour.java
│   ├── bridge_articulation.cpp
│   ├── bridge.cpp
│   ├── EulerTour.java
│   ├── inp.txt
│   ├── input1.txt
│   ├── output1.txt
│   └── output.txt
├── G6: Euler Circuit
│   ├── best euler tour.cpp
│   ├── euler tours.cpp
│   └── inp.txt
├── G7: Strongly Connected Compound
│   ├── inp.txt
│   ├── kosaraju algorithm for SCC.cpp
│   ├── KosarajuAlgorithm.java
│   ├── scc.cpp
│   ├── topological Order.cpp
│   └── TopologicalOrder.java
├── G8: Minimum Spanning Tree
│   ├── input1.txt
│   ├── input2.txt
│   ├── input3.txt
│   ├── input4.txt
│   ├── Kruskal Algo Test Driver Code.py
│   ├── Kruskal.java
│   ├── Kruskal_MST.cpp
│   ├── Prim Algo Test Driver Code.py
│   ├── Prim_MST.cpp
│   ├── Prim’s and Kruskal’s Algorithm for Minimum Spanning Tree Analysis.pdf
│   ├── Prims.java
│   ├── Random_Graph_Generation.py
│   └── README.md
├── G9: Shortest Path Algorithm
│   ├── G9.1: Single Source Shortest Path
│   │   ├── 743.network-delay-time.cpp
│   │   ├── bellmanford.cpp
│   │   ├── dijkastra.cpp
│   │   ├── inputdj.txt
│   │   └── Readme.md
│   └── G9.2: All Pair Shortest Path
│       ├── floydwarshallworking.cpp
│       ├── inputdj.txt
│       ├── jhonsonfinal.cpp
│       ├── jhonsons2working.cpp
│       ├── jhonsonsalgorithm.cpp
│       ├── jhonsonscoded.cpp
│       └── output.txt
├── Greedy: Huffman Coding
│   ├── hf1.cpp
│   ├── hf2.cpp
│   └── hftemplate.cpp
├── LICENSE
├── NF0: Network Flow Basic
│   ├── dinicsAlgo.java
│   ├── dinic's algprithm.cpp
│   ├── driver2.cpp
│   ├── driver.cpp
│   ├── edmond-karp-coded.cpp
│   ├── edmond-karp.cpp
│   ├── edmondkarp_fordfulkerson.cpp
│   ├── inp.txt
│   ├── mbm_maxflow.cpp
│   ├── showsir2.sh
│   ├── showsir.sh
│   └── sirinput.txt
├── NT1: Eucleadian Algorithm GCD
│   ├── gcd_extended.cpp
│   ├── Linear_diaphantine_eqn.png
│   ├── Linear_Diophantine_Equations.cpp
│   ├── multiplicative_modulo_inverse.cpp
│   └── Multiplicative_Modulo_Inverse_using_extended_Eucledian.png
├── README.md
├── Sort1: Sorting Algo
│   ├── CountingInversionUsingMergeSort.cpp
│   └── sorting.cpp
└── T1: Segment Tree
    ├── FLIPCOIN-codechef.cpp
    ├── h.cpp
    ├── Readme.md
    ├── segmenttree.cpp
    └── segment+tree+with+lazy+propagation.cpp
